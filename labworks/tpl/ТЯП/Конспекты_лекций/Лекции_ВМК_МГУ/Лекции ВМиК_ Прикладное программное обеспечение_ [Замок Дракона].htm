<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0047)http://www.ergeal.ru/txt/archive/cs/ppo/2-1.htm -->
<HTML><HEAD><TITLE>Лекции ВМиК. Прикладное программное обеспечение. [Замок Дракона]</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251"><LINK 
href="Лекции ВМиК_ Прикладное программное обеспечение_ [Замок Дракона].files/dc.css" 
type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY bgColor=#bbbdd0>
<CENTER><A href="http://www.ergeal.ru/archive/cs/ppo/2-1.htm">полная 
версия</A></CENTER>
<CENTER style="WIDTH: 80%"><A 
href="http://www.palmshop.ru/?from_partner=5486">Интернет-магазин 
<B>PalmShop.ru</B> - карманные компьютеры, цифровые фотокамеры, память, 
ноутбуки, телефоны, плееры, бесплатная доставка, официальная 
гарантия.</A></CENTER><BR>
<CENTER>
<H1>Замок Дракона</H1>
<H3>Б &nbsp; Е &nbsp; З &nbsp; &nbsp; &nbsp; Б &nbsp; А &nbsp; Ш &nbsp; Н &nbsp; 
И</H3></CENTER>
<CENTER><A href="http://www.ergeal.ru/txt/index.htm">На главную</A></CENTER><A 
class=big href="http://www.ergeal.ru/txt/index.htm"></A>/ <A class=big 
href="http://www.ergeal.ru/txt/archive/index.htm">Архивы Замка Дракона</A> / <A 
class=big href="http://www.ergeal.ru/txt/archive/cs/index.htm">Лекции ВМиК</A> / 
<A class=big href="http://www.ergeal.ru/txt/archive/cs/ppo/index.htm">Прикладное 
программное обеспечение</A> / <FONT 
style="FONT-WEIGHT: bold; FONT-SIZE: 14px; FONT-FAMILY: arial">Элементы теории 
формальных языков и грамматик</FONT><BR><BR>
<CENTER><I>Волкова И.А., Руденко Т.В.</I><BR><B>Системное программное 
обеспечение</B>
<H1>Формальные грамматики и языки.<BR>Элементы теории трансляции.</H1>
<H3>ЭЛЕМЕНТЫ ТЕОРИИ ФОРМАЛЬНЫХ ЯЗЫКОВ И ГРАММАТИК</H3>
<H3 align=center>Введение.</H3></CENTER>
<P>В этом разделе изложены некоторые аспекты теории формальных языков, 
существенные с точки зрения трансляции. Здесь введены базовые понятия и даны 
определения, связанные с одним из основных механизмов определения языков - 
грамматиками, приведена наиболее распространенная классификация грамматик (по 
Хомскому). Особое внимание уделяется контекстно-свободным грамматикам и, в 
частности, их важному подклассу - регулярным грамматикам. Грамматики этих 
классов широко используются при трансляции языков программирования. Здесь не 
приводятся доказательства сформулированных фактов, свойств, теорем, 
доказательства правильности алгоритмов; их можно найти в книгах, указанных в 
списке литературы. 
<P>
<H3 align=center><B>Основные понятия и определения</B></H3><B>Определение:</B> 
<I>алфавит</I> - это конечное множество символов. 
<P>Предполагается, что термин "символ" имеет достаточно ясный интуитивный смысл 
и не нуждается в дальнейшем уточнении. 
<P>
<P><B>Определение: </B><I>цепочкой символов в алфавите V</I> называется любая 
конечная последовательность символов этого алфавита. 
<P>
<P><B>Определение:</B> цепочка, которая не содержит ни одного символа, 
называется <I>пустой цепочкой</I>. Для ее обозначения будем использовать символ 
&#949;. 
<P>Более формально цепочка символов в алфавите V определяется следующим образом: 

<P>(1)&nbsp;&nbsp;&nbsp;&nbsp;&#949; - цепочка в алфавите V; 
<P>(2)&nbsp;&nbsp;&nbsp;&nbsp;если &#945; - цепочка в алфавите V и a - символ этого 
алфавита, то &#945;a - цепочка в алфавите V; 
<P>(3)&nbsp;&nbsp;&nbsp;&nbsp;&#946; - цепочка в алфавите V тогда и только тогда, 
когда она является таковой в силу (1) и (2). 
<P>
<P><B>Определение:</B> если &#945; и &#946; - цепочки, то цепочка &#945;&#946; называется 
<I>конкатенацией (</I>или<I> сцеплением)</I> цепочек &#945; и &#946;. 
<P>Например, если &#945; = ab и &#946; = cd, то &#945;&#946; = abcd. 
<P>Для любой цепочки &#945; всегда &#945;&#949; = &#949;&#945; = &#945;. 
<P>
<P><B>Определение:</B> <I>обращением (</I>или<I> реверсом) </I>цепочки &#945; 
называется цепочка, символы которой записаны в обратном порядке. 
<P>Обращение цепочки &#945; будем обозначать &#945;<SUP>R</SUP>. 
<P>Например, если &#945; = abcdef, то &#945;<SUP>R</SUP> = fedcba. 
<P>Для пустой цепочки: &#949; = &#949;<SUP>R</SUP>. 
<P>
<P><B>Определение: </B>n-ой степенью цепочки &#945; (будем обозначать &#945;<SUP>n</SUP>) 
называется конкатенация n цепочек &#945;. 
<P>&#945;<SUP>0</SUP> = &#949;; &#945;<SUP>n</SUP> = &#945;&#945;<SUP>n-1</SUP> = &#945;<SUP>n-1</SUP>&#945;. 
<P>
<P><B>Определение:</B> <I>длина цепочки </I>- это число составляющих ее 
символов. 
<P>Например, если &#945; = abcdefg, то длина &#945; равна 7. 
<P>Длину цепочки &#945; будем обозначать | &#945; |. Длина &#949; равна 0. 
<P>
<P><B>Определение:</B> <I>язык</I> в алфавите V - это подмножество цепочек 
конечной длины в этом алфавите. 
<P>
<P><B>Определение:</B> обозначим через V<SUP>*</SUP> множество, содержащее все 
цепочки в алфавите V, включая пустую цепочку &#949;. 
<P>Например, если V={0,1}, то V<SUP>*</SUP> = {&#949;, 0, 1, 00, 11, 01, 10, 000, 
001, 011, ...}. 
<P>
<P><B>Определение:</B> обозначим через V<SUP>+</SUP> множество, содержащее все 
цепочки в алфавите V, исключая пустую цепочку &#949;. 
<P>Следовательно, V<SUP>*</SUP> = V<SUP>+</SUP> &#8746; {&#949;}. 
<P>Ясно, что каждый язык в алфавите V является подмножеством множества 
V<SUP>*</SUP>. 
<P>Известно несколько различных способов описания языков [3]. Один из них 
использует порождающие грамматики. Именно этот способ описания языков чаще всего 
будет использоваться нами в дальнейшем. 
<P>
<P><B>Определение:</B> <I>декартовым произведением</I> A &#215; B множеств A и B 
называется множество {(a,b) | a &#8834; A, b &#8834; B}. 
<P>
<P><B>Определение:</B> <I>порождающая грамматика </I>G - это четверка (VT, VN, 
P, S), где 
<P>VT - алфавит <I>терминальных символов (терминалов)</I>, 
<P>VN - алфавит <I>нетерминальных символов (нетерминалов)</I>, не пересекающийся 
с VT, 
<P>P - конечное подмножество множества (VT &#8746; VN)<SUP>+</SUP> &#215; (VT &#8746; 
VN)<SUP>*</SUP>; элемент (&#945;, &#946;) множества P называется <I>правилом вывода</I> и 
записывается в виде &#945; &#8594; &#946;, 
<P>S - <I>начальный символ (цель) </I>грамматики, S &#8834; VN. 
<P>
<P>Для записи правил вывода с одинаковыми левыми частями</FONT> 
<P>&#945; &#8594; &#946;<SUB>1 </SUB>&#945; &#8594; &#946;<SUB>2</SUB> ... &#945; &#8594; &#946;<SUB>n</SUB> 
<P>будем пользоваться сокращенной записью 
<P>&#945; &#8594; &#946;<SUB>1</SUB> | &#946;<SUB>2</SUB> |...| &#946;<SUB>n</SUB>. 
<P>Каждое &#946;<SUB>i </SUB>, i= 1, 2, ... ,n , будем называть <I>альтернативой</I> 
правила вывода из цепочки &#945;. 
<P>
<P>Пример грамматики:</FONT> 
<P>G1 = ({0,1}, {A,S}, P, S), 
<P>где P состоит из правил 
<P>S &#8594; 0A1 
<P>0A &#8594; 00A1 
<P>A &#8594; &#949; 
<P>
<P><B>Определение:</B> цепочка &#946; &#8834; (VT &#8746; VN)<SUP>*</SUP> <I>непосредственно 
выводима </I>из цепочки &#945; &#8834; (VT &#8746; VN)<SUP>+</SUP> в грамматике G = (VT, VN, P, 
S) (обозначим &#945; &#8594; &#946;), если &#945; = &#958;<SUB>1</SUB>&#947;&#958;<SUB>2</SUB>, &#946; = 
&#958;<SUB>1</SUB>&#948;&#958;<SUB>2</SUB>, где &#958;<SUB>1</SUB>, &#958;<SUB>2</SUB>, &#948; &#8834; (VT &#8746; 
VN)<SUP>*</SUP>, &#947; &#8834; (VT &#8746; VN)<SUP>+</SUP> и правило вывода &#947; &#8594; &#948; содержится в 
P. 
<P>Например, цепочка 00A11 непосредственно выводима из 0A1 в грамматике G1. 
<P>
<P><B>Определение:</B> цепочка &#946; &#8834; (VT &#8746; VN)<SUP>*</SUP> <I>выводима </I>из 
цепочки 
<P>&#945; &#8834; (VT &#8746; VN)<SUP>+</SUP> в грамматике G = (VT, VN, P, S) (обозначим &#945; &#8658; &#946;), 
если существуют цепочки &#947;<SUB>0</SUB>, &#947;<SUB>1</SUB>, ... , &#947;<SUB>n </SUB>(n&#8805;0), 
такие, что &#945; = &#947;<SUB>0</SUB> &#8594; &#947;<SUB>1</SUB> &#8594; ... &#8594; &#947;<SUB>n</SUB>= &#946;. 
<P>
<P><B>Определение:</B> последовательность &#947;<SUB>0</SUB>, &#947;<SUB>1</SUB>, ... , 
&#947;<SUB>n </SUB>называется <I>выводом длины n</I>. 
<P>Например, S &#8658; 000A111 в грамматике G1 (см. пример выше), т.к. существует 
вывод S &#8594; 0A1 &#8594; 00A11 &#8594; 000A111. Длина вывода равна 3. 
<P>
<P><B>Определение:</B> <I>языком, порождаемым грамматикой</I> G = (VT, VN, P, 
S), называется множество L(G)={&#945; &#8834; VT<SUP>* </SUP>| S &#8658; &#945;}. 
<P>Другими словами, L(G) - это все цепочки в алфавите VT, которые выводимы из S 
с помощью P. 
<P>Например, L(G1) = {0<SUP>n</SUP>1<SUP>n</SUP> | n&gt;0}. 
<P>
<P><B>Определение:</B> цепочка &#945; &#8834; (VT &#8746; VN)<SUP>*</SUP>, для которой S &#8658; &#945;, 
называется <I>сентенциальной формой</I> в грамматике G = (VT, VN, P, S). 
<P>Таким образом, язык, порождаемый грамматикой, можно определить как множество 
терминальных сентенциальных форм. 
<P>
<P><B>Определение:</B> грамматики G1 и G2 называются <I>эквивалентными</I>, если 
L(G1) = L(G2). 
<P>Например, G1 = ({0,1}, {A,S}, P1, S) и G2 = ({0,1}, {S}, P2, S), где 
<P>&nbsp;&nbsp;&nbsp;&nbsp;P1:&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 
0A1&nbsp;&nbsp;&nbsp;&nbsp;P2:&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 0S1 | 01 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0A &#8594; 00A1 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; &#949; 
<P>эквивалентны, т.к. обе порождают язык</FONT> 
<P>L(G1) = L(G2) = {0<SUP>n</SUP>1<SUP>n</SUP> | n&gt;0}. 
<P>
<P><B>Определение:</B> грамматики G1 и G2 <I>почти эквивалентны</I>, если 
<P>L(G1) &#8746; {&#949;} = L(G2) &#8746; {&#949;}. 
<P>Другими словами, грамматики почти эквивалентны, если языки, ими порождаемые, 
отличаются не более, чем на &#949;. 
<P>Например, G1 = ({0,1}, {A,S}, P1, S) и G2 = ({0,1}, {S}, P2, S), где 
<P>&nbsp;&nbsp;&nbsp;&nbsp;P1:&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 
0A1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2:&nbsp;&nbsp;&nbsp;&nbsp;S 
&#8594; 0S1 | &#949; 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0A &#8594; 00A1 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; &#949; 
<P>почти эквивалентны, т.к. L(G1)={0<SUP>n</SUP>1<SUP>n</SUP> | n&gt;0}, а 
L(G2)={0<SUP>n</SUP>1<SUP>n</SUP> | n&#8805;0}, т.е. L(G2) состоит из всех цепочек 
языка L(G1) и пустой цепочки, которая в L(G1) не входит.</FONT> 
<P>
<H3 align=center><B>Классификация грамматик и языков по 
Хомскому</B></H3><I>(грамматики классифицируются по виду их правил вывода)</I> 
<P><B>ТИП 0: </B>
<P>Грамматика G = (VT, VN, P, S) называется <I>грамматикой типа 0</I>, если на 
правила вывода не накладывается никаких ограничений (кроме тех, которые указаны 
в определении грамматики). 
<P>
<P><B>ТИП 1:</B> 
<P>Грамматика G = (VT, VN, P, S) называется <I>неукорачивающей</I> 
<I>грамматикой</I>, если каждое правило из P имеет вид &#945; &#8594; &#946;, где &#945; &#8834; (VT &#8746; 
VN)<SUP>+</SUP>, &#946; &#8834; (VT &#8746; VN)<SUP>+</SUP> и | &#945; | | &#946; |. 
<P>
<P>Грамматика G = (VT, VN, P, S) называется <I>контекстно-зависимой (КЗ)</I>, 
если каждое правило из P имеет вид &#945; &#8594; &#946;, где &#945; = &#958;<SUB>1</SUB>A&#958;<SUB>2</SUB>; &#946; 
= &#958;<SUB>1</SUB>&#947;&#958;<SUB>2</SUB>; A &#8834; VN; &#947; &#8834; (VT &#8746; VN)<SUP>+</SUP>; 
&#958;<SUB>1</SUB>,&#958;<SUB>2</SUB> &#8834; (VT &#8746; VN)<SUP>*</SUP>. 
<P>
<P><I>Грамматику типа 1</I> можно определить как неукорачивающую либо как 
контекстно-зависимую. 
<P>Выбор определения не влияет на множество языков, порождаемых грамматиками 
этого класса, поскольку доказано, что множество языков, порождаемых 
неукорачивающими грамматиками, совпадает с множеством языков, порождаемых 
КЗ-грамматиками. 
<P>
<P><B>ТИП 2:</B> 
<P>Грамматика G = (VT, VN, P, S) называется<I> контекстно-свободной (КС)</I>, 
если каждое правило из Р имеет вид A &#8594; &#946;, где A &#8834; VN, &#946; &#8834; (VT &#8746; VN)<SUP>+</SUP>. 

<P>
<P>Грамматика G = (VT, VN, P, S) называется <I>укорачивающей 
контекстно-свободной (УКС)</I>, если каждое правило из Р имеет вид A &#8594; &#946;, где A 
&#8834; VN, &#946; &#8834; (VT &#8746; VN)<SUP>*</SUP>. 
<P>
<P><I>Грамматику типа 2</I> можно определить как контекстно-свободную либо как 
укорачивающую контекстно-свободную. 
<P>Возможность выбора обусловлена тем, что для каждой УКС-грамматики существует 
почти эквивалентная КС-грамматика. 
<P>
<P><B>ТИП 3:</B> 
<P>Грамматика G = (VT, VN, P, S) называется <I>праволинейной</I>, если каждое 
правило из Р имеет вид A &#8594; tB либо A &#8594; t, где A &#8834; VN, B &#8834; VN, t &#8834; VT. 
<P>
<P>Грамматика G = (VT, VN, P, S) называется <I>леволинейной</I>, если каждое 
правило из Р имеет вид A &#8594; Bt либо A &#8594; t, где A &#8834; VN, B &#8834; VN, t &#8834; VT. 
<P>
<P><I>Грамматику типа 3 (регулярную, Р-грамматику)</I> можно определить как 
праволинейную либо как леволинейную. 
<P>Выбор определения не влияет на множество языков, порождаемых грамматиками 
этого класса, поскольку доказано, что множество языков, порождаемых 
праволинейными грамматиками, совпадает с множеством языков, порождаемых 
леволинейными грамматиками. 
<P>
<P><B>Соотношения между типами грамматик:</B> 
<P>(1) любая регулярная грамматика является КС-грамматикой; 
<P>(2) любая регулярная грамматика является УКС-грамматикой; 
<P>(3) любая КС-грамматика является КЗ-грамматикой; 
<P>(4) любая КС-грамматика является неукорачивающей грамматикой; 
<P>(5) любая КЗ-грамматика является грамматикой типа 0. 
<P>(6) любая неукорачивающая грамматика является грамматикой типа 0. 
<P><B>Замечание:</B> УКС-грамматика, содержащая правила вида A &#8594; &#949;, не является 
КЗ-грамматикой и не является неукорачивающей грамматикой. 
<P>
<P><B>Определение:</B> язык L(G) является <I>языком типа k</I>, если его можно 
описать грамматикой типа k. 
<P>
<P><B>Соотношения между типами языков:</B> 
<P>(1) каждый регулярный язык является КС-языком, но существуют КС-языки, 
которые не являются регулярными (например, L = {a<SUP>n</SUP>b<SUP>n </SUP>| 
n&gt;0}). 
<P>(2) каждый КС-язык является КЗ-языком, но существуют КЗ-языки, которые не 
являются КС-языками (например, L = {a<SUP>n</SUP>b<SUP>n</SUP>c<SUP>n </SUP>| 
n&gt;0}). 
<P>(3) каждый КЗ-язык является языком типа 0. 
<P><B>Замечание:</B> УКС-язык, содержащий пустую цепочку, не является КЗ-языком. 

<P><B>Замечание:</B> следует подчеркнуть, что если язык задан грамматикой типа 
k, то это не значит, что не существует грамматики типа k’ (k’&gt;k), описывающей 
тот же язык. Поэтому, когда говорят о языке типа k, обычно имеют в виду 
максимально возможный номер k. 
<P>
<P><B>Например</B>, КЗ-грамматика G1 = ({0,1}, {A,S}, P1, S) и 
<P>КС-грамматика G2 = ({0,1}, {S}, P2, S), где 
<P>&nbsp;&nbsp;&nbsp;&nbsp;P1:&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 
0A1&nbsp;&nbsp;&nbsp;&nbsp;P2:&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 0S1 | 01 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0A &#8594; 00A1 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; &#949; 
<P>описывают один и тот же язык L = L(G1) = L(G2) = { 0<SUP>n</SUP>1<SUP>n</SUP> 
| n&gt;0}. Язык L называют КС-языком, т.к. существует КС-грамматика, его 
описывающая. Но он не является регулярным языком,т.к. не существует регулярной 
грамматики, описывающей этот язык [3].</FONT> 
<P>
<H3 align=center><B>Примеры грамматик и языков.</B></H3><B>Замечание: </B>если 
при описании грамматики указаны только правила вывода Р, то будем считать, что 
большие латинские буквы обозначают нетерминальные символы, S - цель грамматики, 
все остальные символы - терминальные. 
<P>
<P>1) Язык типа 0: L = {a<SUP>2</SUP> <SUB><IMG height=23 
src="Лекции ВМиК_ Прикладное программное обеспечение_ [Замок Дракона].files/image002.gif" 
width=35 border=0></SUB>| n &#8805; 1} 
<P>G(L):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aaCFD 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F &#8594; AFB | AB 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AB &#8594; bBA 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ab &#8594; bA 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AD &#8594; D 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cb &#8594; bC 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CB &#8594; C 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bCD &#8594; &#949; 
<P>
<P>2) Язык типа 2: L={цепочки из 0 и 1 с одинаковым числом 0 и 1} 
<P>G(L):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; ASB | AB 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AB &#8594; BA 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; 0 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; 1 
<P>
<P>3) Язык типа 2: L = {(ac)<SUP>n</SUP> (cb)<SUP>n</SUP> | n &gt; 0} 
<P>G(L):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aQb | accb 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q &#8594; cSc 
<P>
<P>4) Язык типа 3: L = {&#969; &#8869; | &#969; &#8834; {a,b}<SUP>+</SUP>, где нет двух рядом стоящих 
а} 
<P>G(L):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; A&#8869; | B&#8869; 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; a | Ba 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; b | Bb | Ab 
<P>
<H3 align=center><B>Разбор цепочек</B></H3>Цепочка принадлежит языку, 
порождаемому грамматикой, только в том случае, если существует ее вывод из цели 
этой грамматики. Процесс построения такого вывода ( а, следовательно, и 
определения принадлежности цепочки языку) называется <I>разбором</I>. 
<P>С практической точки зрения наибольший интерес представляет разбор по<B> 
контекстно-свободным (КС и УКС) грамматикам.</B> Их порождающей мощности 
достаточно для описания большей части синтаксической структуры языков 
программирования, для различных подклассов КС-грамматик имеются хорошо 
разработанные практически приемлемые способы решения задачи разбора. 
<P>Рассмотрим основные понятия и определения, связанные с разбором по 
КС-грамматике. 
<P>
<P><B>Определение:</B> вывод цепочки &#946; &#8834; (VT)<SUP>*</SUP> из S &#8834; VN в 
КС-грамматике G = (VT, VN, P, S), называется<I> левым (левосторонним)</I>, если 
в этом выводе каждая очередная сентенциальная форма получается из предыдущей 
заменой самого левого нетерминала. 
<P>
<P><B>Определение:</B> вывод цепочки &#946; &#8834; (VT)<SUP>*</SUP> из S &#8834; VN в 
КС-грамматике G = (VT, VN, P, S), называется<I> правым (правосторонним)</I>, 
если в этом выводе каждая очередная сентенциальная форма получается из 
предыдущей заменой самого правого нетерминала. 
<P>
<P>В грамматике для одной и той же цепочки может быть несколько выводов, 
эквивалентных в том смысле, что в них в одних и тех же местах применяются одни и 
те же правила вывода, но в различном порядке. 
<P>Например, для цепочки a+b+a в грамматике</FONT> 
<P>G = ({a,b}, {S,T}, {S &#8594; T | T+S; T &#8594; a|b}, S) 
<P>можно построить выводы: 
<P>(1)&nbsp;&nbsp;&nbsp;&nbsp;S&#8594;T+S&#8594;T+T+S&#8594;T+T+T&#8594;a+T+T&#8594;a+b+T&#8594;a+b+a 
<P>(2)&nbsp;&nbsp;&nbsp;&nbsp;S&#8594;T+S&#8594;a+S&#8594;a+T+S&#8594;a+b+S&#8594;a+b+T&#8594;a+b+a 
<P>(3)&nbsp;&nbsp;&nbsp;&nbsp;S&#8594;T+S&#8594;T+T+S&#8594;T+T+T&#8594;T+T+a&#8594;T+b+a&#8594;a+b+a 
<P>Здесь (2) - левосторонний вывод, (3) - правосторонний, а (1) не является ни 
левосторонним, ни правосторонним, но все эти выводы являются эквивалентными в 
указанном выше смысле. 
<P>
<P>Для КС-грамматик можно ввести удобное графическое представление вывода, 
называемое деревом вывода, причем для всех эквивалентных выводов деревья вывода 
совпадают. 
<P>
<P><B>Определение:</B> дерево называется <I>деревом вывода (</I>или<I> деревом 
разбора) в КС-грамматике</I> G = {VT, VN, P, S), если выполнены следующие 
условия: 
<P>(1)&nbsp;&nbsp;&nbsp;&nbsp;каждая вершина дерева помечена символом из 
множества (VN &#8746; VT &#8746; &#949;), при этом корень дерева помечен символом S; листья - 
символами из (VT &#8746; &#949;); 
<P>(2)&nbsp;&nbsp;&nbsp;&nbsp;если вершина дерева помечена символом A &#8834; VN, а ее 
непосредственные потомки - символами a<SUB>1</SUB>, a<SUB>2</SUB>, ... , 
a<SUB>n</SUB>, где каждое a<SUB>i</SUB> &#8834; (VT &#8746; VN), то A &#8594; 
a<SUB>1</SUB>a<SUB>2</SUB>...a<SUB>n</SUB> - правило вывода в этой грамматике; 
<P>(3)&nbsp;&nbsp;&nbsp;&nbsp;если вершина дерева помечена символом A &#8834; VN, а ее 
единственный непосредственный потомок помечен символом &#949;, то A &#8594; &#949; - правило 
вывода в этой грамматике. 
<P>
<P><B>Пример</B> дерева вывода для цепочки a+b+a в грамматике G:</FONT> 
<P>
<P><IMG height=224 
src="Лекции ВМиК_ Прикладное программное обеспечение_ [Замок Дракона].files/image004.gif" 
width=237 border=0> 
<P>
<P><B>Определение:</B> КС-грамматика G называется <I>неоднозначной</I>, если 
существует хотя бы одна цепочка &#945; &#8834; L(G), для которой может быть построено два 
или более различных деревьев вывода. 
<P>Это утверждение эквивалентно тому, что цепочка &#945; имеет два или более разных 
левосторонних (или правосторонних) выводов. 
<P>
<P><B>Определение:</B> в противном случае грамматика называется 
<I>однозначной</I>. 
<P>
<P><B>Определение:</B> язык, порождаемый грамматикой, называется 
<I>неоднозначным</I>, если он не может быть порожден никакой однозначной 
грамматикой. 
<P>
<P><B>Пример</B> неоднозначной грамматики:</FONT> 
<P>G = ({if, then, else, a, b}, {S}, P, S), 
<P>где P = {S &#8594; if b then S else S | if b then S | a}. 
<P>В этой грамматике для цепочки if b then if b then a else a можно построить 
два дерева вывода. 
<P>
<P>Однако это не означает, что язык L(G) обязательно неоднозначный. Определенная 
нами <B>неоднозначность - это свойство грамматики, а не языка</B>, т.е. для 
некоторых неоднозначных грамматик существуют эквивалентные им однозначные 
грамматики. Если грамматика используется для определения языка программирования, 
то она должна быть однозначной. В приведенном выше примере разные деревья вывода 
предполагают соответствие else разным then. Если договориться, что else должно 
соответствовать ближайшему к нему then, и подправить грамматику G, то 
неоднозначность будет устранена: 
<P>S &#8594; if b then S | if b then S’ else S | a 
<P>S’ &#8594; if b then S’ else S’ | a 
<P>
<P>Проблема, порождает ли данная КС-грамматика однозначный язык (т.е. существует 
ли эквивалентная ей однозначная грамматика), является <B>алгоритмически 
неразрешимой.</B> 
<P>Однако можно указать некоторые виды правил вывода, которые приводят к 
неоднозначности:</FONT> 
<P>
<UL>
  <LI>A &#8594; AA | &#945; 
  <LI>A &#8594; A&#945;A | &#946; 
  <LI>A &#8594; &#945;A | A&#946; | &#947; 
  <LI>A &#8594; &#945;A | &#945;A&#946;A | &#947;</LI></UL>
<P><B>Пример</B> неоднозначного КС-языка:</FONT> 
<P>L = {a<SUP>i </SUP>b<SUP>j </SUP>c<SUP>k </SUP>| i = j или j = k}. 
<P>Интуитивно это объясняется тем, что цепочки с i=j должны порождаться группой 
правил вывода, отличных от правил, порождающих цепочки с j=k. Но тогда, по 
крайней мере, некоторые из цепочек с i=j=k будут порождаться обеими группами 
правил и, следовательно, будут иметь по два разных дерева вывода. Доказательство 
того, что КС-язык L неоднозначный, приведен в [3, стр. 235-236]. Одна из 
грамматик, порождающих L, такова: 
<P>S &#8594; AB | DC 
<P>A &#8594; aA | &#949; 
<P>B &#8594; bBc | &#949; 
<P>C &#8594; cC | &#949; 
<P>D &#8594; aDb | &#949; 
<P>Очевидно, что она неоднозначна. 
<P>
<P>Дерево вывода можно строить <I>нисходящим</I> либо <I>восходящим</I> 
способом. 
<P>При нисходящем разборе дерево вывода формируется от корня к листьям; на 
каждом шаге для вершины, помеченной нетерминальным символом, пытаются найти 
такое правило вывода, чтобы имеющиеся в нем терминальные символы 
“проектировались” на символы исходной цепочки. 
<P>Метод восходящего разбора заключается в том, что исходную цепочку пытаются 
“свернуть” к начальному символу S; на каждом шаге ищут подцепочку, которая 
совпадает с правой частью какого-либо правила вывода; если такая подцепочка 
находится, то она заменяется нетерминалом из левой части этого правила. 
<P>Если грамматика однозначная, то при любом способе построения будет получено 
одно и то же дерево разбора.</FONT> 
<P>
<H3 align=center><B>Преобразования грамматик</B></H3>В некоторых случаях 
КС-грамматика может содержать недостижимые и бесплодные символы, которые не 
участвуют в порождении цепочек языка и поэтому могут быть удалены из грамматики. 

<P>
<P><B>Определение:</B> символ x &#8834; (VT &#8746; VN) называется <I>недостижимым</I> в 
грамматике G = (VT, VN, P, S), если он не появляется ни в одной сентенциальной 
форме этой грамматики. 
<P>
<P><B>Алгоритм удаления недостижимых символов:</B> 
<P>Вход: КС-грамматика G = (VT, VN, P, S) 
<P>Выход: КС-грамматика G’ = (VT’, VN’, P’, S), не содержащая недостижимых 
символов, для которой L(G) = L(G’). 
<P>Метод: 
<P>
<OL>
  <LI>V<SUB>0</SUB> = {S}; i = 1. 
  <LI>V<SUB>i</SUB> = {x | x &#8834; (VT &#8746; VN), в P есть A &#8594; &#945;x&#946; и A &#8834; 
  V<SUB>i-1</SUB>} &#8746; V<SUB>i-1</SUB>. 
  <LI>Если V<SUB>i</SUB> &#8800; V<SUB>i-1</SUB>, то i = i+1 и переходим к шагу 2, 
  иначе VN’ = 
  <P>V<SUB>i</SUB> &#8745; VN; VT’ = V<SUB>i</SUB> &#8745; VT; P’ состоит из правил 
  множества P, содержащих только символы из Vi; G’ = (VT’, VN’, P’, 
S).</P></LI></OL>
<P><B>Определение:</B> символ A &#8834; VN называется <I>бесплодным</I> в грамматике G 
= (VT, VN, P, S), если множество { &#945; &#8834; VT<SUP>*</SUP> | A &#8658; &#945;} пусто. 
<P>
<P><B>Алгоритм удаления бесплодных символов:</B> 
<P>Вход: КС-грамматика G = (VT, VN, P, S). 
<P>Выход: КС-грамматика G’ = (VT, VN’, P’, S), не содержащая бесплодных 
символов, для которой L(G) = L(G’). 
<P>Метод: 
<P>Рекурсивно строим множества N<SUB>0</SUB>, N<SUB>1</SUB>, ... </FONT>
<P>
<OL>
  <LI>N<SUB>0</SUB> = &#8709;, i = 1. 
  <LI>N<SUB>i</SUB> = {A | (A &#8594; &#945;) &#8834; P и &#945; &#8834; (N<SUB>i-1</SUB> &#8746; VT)<SUP>*</SUP>} 
  &#8746; N<SUB>i-1</SUB>. 
  <LI>Если N<SUB>i</SUB> &#8800; N<SUB>i-1</SUB>, то i = i+1 и переходим к шагу 2, 
  иначе VN’ = N<SUB>i</SUB>; P’ состоит из правил множества P, содержащих только 
  символы из VN’ &#8746; VT; G’ = (VT, VN’, P’, S).</LI></OL>
<P><B>Определение:</B> КС-грамматика G называется<I> приведенной,</I> если в ней 
нет недостижимых и бесплодных символов. 
<P>
<P><B>Алгоритм приведения грамматики</B>:</FONT> 
<P>
<UL>
  <LI>обнаруживаются и удаляются все бесплодные нетерминалы. 
  <LI>обнаруживаются и удаляются все недостижимые символы.</LI></UL>Удаление 
символов сопровождается удалением правил вывода, содержащих эти символы. 
<P>
<P><B>Замечание: е</B>сли в этом алгоритме переставить шаги (1) и (2), то не 
всегда результатом будет приведенная грамматика. 
<P>
<P>Для описания синтаксиса языков программирования стараются использовать 
однозначные приведенные КС-грамматики.</FONT> 
<P>
<H3 align=center><B>Задачи.</B></H3>1. Дана грамматика. Построить вывод заданной 
цепочки. 
<P>&nbsp;&nbsp;&nbsp;&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; T | T+S | 
T-S&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aSBC | abC 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T &#8594; F | 
F*T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CB &#8594; BC 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F &#8594; a | 
b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bB &#8594; bb 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Цепочка a-b*a+b 
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bC &#8594; bc 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cC 
&#8594; cc 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Цепочка 
aaabbbccc . 
<P>
<P>2. Построить все сентенциальные формы для грамматики с правилами: 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; A+B | B+A 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; a 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; b 
<P>
<P>3. Какой язык порождается грамматикой с правилами: 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 
APA&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aQb | &#949; 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P &#8594; + | 
-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q &#8594; cSc 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; a | b 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;c)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 
1B&nbsp;&nbsp;&nbsp;&nbsp;d)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; A | SA | SB 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; B0 | 
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; a 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B 
&#8594; b 
<P>
<P>4. Построить грамматику, порождающую язык :</FONT> 
<P>
<OL>
  <LI>L = {a<SUP>n</SUP> b<SUP>m</SUP> | n, m &#8805; 1} 
  <LI>L = {&#945;c&#946;c&#947;c | &#945;, &#946;, &#947; - любые цепочки из a и b} 
  <LI>L = {a<SUB>1</SUB> a<SUB>2</SUB> ... a<SUB>n</SUB> a<SUB>n</SUB> ... 
  a<SUB>2</SUB> a<SUB>1</SUB> | a<SUB>i</SUB> = 0 или 1, n &#8805; 1} 
  <LI>L = {a<SUP>n</SUP> b<SUP>m</SUP> | n &#8800; m ; n, m &#8805; 0} 
  <LI>L = {цепочки из 0 и 1 с неравным числом 0 и 1} 
  <LI>L = {&#945;&#945; | &#945; &#8834; {a,b}<SUP>+</SUP>} 
  <LI>L = {&#969; | &#969; &#8834; {0,1}<SUP>+</SUP> и содержит равное количество 0 и 1, причем 
  любая подцепочка, взятая с левого конца, содержит единиц не меньше, чем 
  нулей}. 
  <LI>L = {(a<SUP>2m</SUP> b<SUP>m</SUP>)<SUP>n</SUP> | m &#8805; 1, n &#8805; 0} 
  <LI>L = {<SUB><IMG height=23 
  src="Лекции ВМиК_ Прикладное программное обеспечение_ [Замок Дракона].files/image006.gif" 
  width=32 border=0></SUB>&#8869; | n &#8805; 1} 
  <LI>L = {<SUB><IMG height=23 
  src="Лекции ВМиК_ Прикладное программное обеспечение_ [Замок Дракона].files/image008.gif" 
  width=24 border=0></SUB> | n &#8805; 1} 
  <LI>L = {<SUB><IMG height=23 
  src="Лекции ВМиК_ Прикладное программное обеспечение_ [Замок Дракона].files/image010.gif" 
  width=32 border=0></SUB>| n &#8805; 1}</LI></OL>
<P>5. К какому типу по Хомскому относится грамматика с правилами: 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; a | 
Ba&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; Ab 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; Bb | 
b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; Aa | ba 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;c)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 0A1 | 
01&nbsp;&nbsp;&nbsp;&nbsp;d)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; AB 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0A &#8594; 
00A1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AB &#8594; BA 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; 
01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; a 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B 
&#8594; b 
<P>
<P>6. Эквивалентны ли грамматики с правилами : 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;а)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 
AB&nbsp;&nbsp;&nbsp;&nbsp;и&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; AS | SB | AB 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; a | 
Aa&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; a 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; b | 
Bb&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; b 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aSL | 
aL&nbsp;&nbsp;&nbsp;&nbsp;и&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aSBc | abc 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L &#8594; 
Kc&nbsp;&nbsp;&nbsp;&nbsp;cB &#8594; Bc 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cK &#8594; 
Kc&nbsp;&nbsp;&nbsp;&nbsp;bB &#8594; bb 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K &#8594; b 
<P>
<P>7. Построить КС-грамматику, эквивалентную грамматике с правилами: 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;а)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 
aAb&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; AB | ABS 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aA &#8594; 
aaAb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AB &#8594; BA 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; 
&#949;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BA &#8594; AB 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A 
&#8594; a 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B 
&#8594; b 
<P>
<P>8. Построить регулярную грамматику, эквивалентную грамматике с правилами: 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;а)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; A | 
AS&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; A<B>.</B>A 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; a | 
bb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; B | BA 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B 
&#8594; 0 | 1 
<P>
<P>9. Доказать, что грамматика с правилами: 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aSBC | abC 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CB &#8594; BC 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bB &#8594; bb 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bC &#8594; bc 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cC &#8594; cc 
<P>порождает язык L = {a<SUP>n</SUP> b<SUP>n</SUP> c<SUP>n</SUP> | n &#8805; 1}. Для 
этого показать, что в данной грамматике</FONT> 
<P>
<OL>
  <LI>выводится любая цепочка вида a<SUP>n</SUP> b<SUP>n</SUP> c<SUP>n </SUP>(n 
  &#8805; 1) и 
  <LI>не выводятся никакие другие цепочки.</LI></OL>
<P>10. Дана грамматика с правилами: 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; S0 | S1 | D0 | 
D1&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; if B then S | B = E 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D &#8594; 
H.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#917; &#8594; B | B + E 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H &#8594; 0 | 1 | H0 | 
H1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; a | b 
<P>
<P>Построить восходящим и нисходящим методами дерево вывода для цепочки:</FONT> 
<P>
<OL>
  <LI>10.1001 
  <LI>if a then b = a+b+b</LI></OL>
<P>11. Определить тип грамматики. Описать язык, порождаемый этой грамматикой. 
Написать для этого языка КС-грамматику. 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; P&#8869; 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P &#8594; 1P1 | 0P0 | T 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T &#8594; 021 | 120R 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R1 &#8594; 0R 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R0 &#8594; 1 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&#8869;&#8594; 1&#8869; 
<P>
<P>12. Построить регулярную грамматику, порождающую цепочки в алфавите {a, b}, в 
которых символ a не встречается два раза подряд. 
<P>
<P>13. Написать КС-грамматику для языка L, построить дерево вывода и 
левосторонний вывод для цепочки aabbbcccc. 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L = {a<SUP>2n</SUP> 
b<SUP>m</SUP> c<SUP>2k</SUP> | m=n+k, m&gt;1}. 
<P>
<P>14. Построить грамматику, порождающую сбалансированные относительно круглых 
скобок цепочки в алфавите { a, ( , ), &#8869; }. Сбалансированную цепочку &#945; определим 
рекуррентно: цепочка &#945; сбалансирована, если 
<P>a)&nbsp;&nbsp;&nbsp;&nbsp;&#945; не содержит скобок, 
<P>b)&nbsp;&nbsp;&nbsp;&nbsp;&#945; = (&#945;<SUB>1</SUB>) или &#945;= &#945;<SUB>1</SUB> 
&#945;<SUB>2</SUB>, где &#945;<SUB>1</SUB> и &#945;<SUB>2 </SUB>сбалансированы. 
<P>
<P>15. Написать КС-грамматику, порождающую язык L, и вывод для цепочки aacbbbcaa 
в этой грамматике. 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L = {a<SUP>n</SUP> 
cb<SUP>m</SUP> ca<SUP>n</SUP> | n, m&gt;0}. 
<P>
<P>16. Написать КС-грамматику, порождающую язык L, и вывод для цепочки 110000111 
в этой грамматике. 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L = {1<SUP>n</SUP> 
0<SUP>m</SUP> 1<SUP>p</SUP> | n+p&gt;m; n, p, m&gt;0}. 
<P>
<P>17. Дана грамматика G. Определить ее тип; язык, порождаемый этой грамматикой; 
тип языка. 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;G:&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; 0A1 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0A &#8594; 00A1 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; &#949; 
<P>
<P>18. Дан язык L = {1<SUP>3n+2</SUP> 0<SUP>n</SUP> | n&#8805;0}. Определить его тип, 
написать грамматику, порождающую L. Построить левосторонний и правосторонний 
выводы, дерево разбора для цепочки 1111111100. 
<P>
<P>19. Привести пример грамматики, все правила которой имеют вид 
<P>A &#8594; Bt, либо A &#8594; tB, либо A &#8594; t, для которой не существует эквивалентной 
регулярной грамматики. 
<P>
<P>20. Написать общие алгоритмы построения по данным КС-грамматикам G1 и G2, 
порождающим языки L1 и L2, КС-грамматики для</FONT> 
<P>
<OL>
  <LI>L1&#8746;L2 
  <LI>L1 * L2 
  <LI>L1<SUP>*</SUP></LI></OL>
<P><B>Замечание: </B>L =<B> </B>L1 * L2 - это конкатенация языков L1 и L2 т.е. 
<P>L = { &#945;&#946; | &#945; &#8834; L1, &#946; &#8834; L2}; L = L1<SUP>*</SUP> - это итерация языка L1, т.е. 
объединение {&#949;} &#8746; L1 &#8746; L1*L1 &#8746; L1*L1*L1 &#8746; ... 
<P>
<P>21. Написать КС-грамматику для L={&#969;<SUB>i</SUB> 2 &#969;<SUB>i+1</SUB><SUP>R</SUP> 
| i &#8834; N, &#969;<SUB>i</SUB>=(i)<SUB>2</SUB> - двоичное представление числа i, 
&#969;<SUP>R</SUP> - обращение цепочки &#969;}. Написать КС-грамматику для языка L<SUP>* 
</SUP>(см. задачу 20). 
<P>
<P>22. Показать, что грамматика 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#917; &#8594; E+E | E*E | (E) | i 
<P>неоднозначна. Как описать этот же язык с помощью однозначной грамматики? 
<P>
<P>23. Показать, что наличие в КС-грамматике правил вида</FONT> 
<P>
<OL>
  <LI>A &#8594; AA | &#945; 
  <LI>A &#8594; A&#945;A | &#946; 
  <LI>A &#8594; &#945;A | A&#946; | &#947;</LI></OL>где &#945;,&#946;,&#947; &#8834; (VT&#8746;VN)<SUP>*</SUP>, A &#8834; VN, делает ее 
неоднозначной. Можно ли преобразовать эти правила таким образом, чтобы 
полученная эквивалентная грамматика была однозначной? 
<P>
<P>24. Показать, что грамматика G неоднозначна. 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;G:&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; abC | aB 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; bc 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bC &#8594; bc 
<P>
<P>25. Дана КС-грамматика G={VT, VN, P, S}. Предложить алгоритм построения 
множества 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X={A &#8834; VN | A &#8658; &#949;}. 
<P>
<P>26. Для произвольной КС-грамматики G предложить алгоритм, определяющий, пуст 
ли язык L(G). 
<P>
<P>27. Написать приведенную грамматику, эквивалентную данной. 
<P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aABS | 
bCACd&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;S &#8594; aAB | E 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; bAB | cSA | 
cCC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A &#8594; dDA | &#949; 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; bAB | 
cSB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B &#8594; bE | f 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C &#8594; cS | 
c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C &#8594; cAB | dSD | a 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D 
&#8594; eA 
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#917; 
&#8594; fA | g 
<P>
<P>28. Язык называется распознаваемым, если существует алгоритм, который за 
конечное число шагов позволяет получить ответ о принадлежности любой цепочки 
языку. Если число шагов зависит от длины цепочки и может быть оценено до 
выполнения алгоритма, язык называется легко распознаваемым. Доказать, что язык, 
порождаемый неукорачивающей грамматикой, легко распознаваем. 
<P>
<P>29. Доказать, что любой конечный язык, в который не входит пустая цепочка, 
является регулярным языком. 
<P>
<P>30. Доказать, что нециклическая КС-грамматика порождает конечный язык. 
Нетерминальный символ A &#8834; VN - циклический, если в грамматике существует A &#8658; 
&#958;<SUB>1</SUB> A &#958;<SUB>2</SUB> . КС-грамматика называется циклической, если в ней 
имеется хотя бы один циклический символ. 
<P>
<P>31. Показать, что условие цикличности грамматики (см. задачу 30) не является 
достаточным условием бесконечности порождаемого ею языка. 
<P>
<P>32. Доказать, что язык, порождаемый циклической приведенной КС-грамматикой, 
содержащей хотя бы один эффективный циклический символ, бесконечен. Циклический 
символ называется эффективным, если A &#8658; &#945;A&#946;, где |&#945;A&#946;|&gt;1; иначе циклический 
символ называется фиктивным.</FONT> 
<P>
<P></TD><BR>
<CENTER>[<A href="http://www.ergeal.ru/txt/archive/cs/ppo/index.htm">Наверх: в 
начало раздела</A> &#8801; <A 
href="http://www.ergeal.ru/txt/archive/cs/ppo/1-3.htm">Назад: Исправление ошибок 
в русскоязычных текстах</A> &#8801; <A 
href="http://www.ergeal.ru/txt/archive/cs/ppo/2-2.htm">Вперед: Элементы теории 
трансляции</A> &#8801; <A 
href="http://www.ergeal.ru/txt/archive/cs/ppo/2-1.htm">Здесь: Элементы теории 
формальных языков и грамматик</A>]</CENTER><BR></BODY></HTML>
